# Defining the IR

Before we can define the [parser](./parser.md), we need to define the intermediate representation (IR) that we will use for `calc` programs.
In the [basic structure](./structure.md), we defined some "pseudo-Rust" structures like `Statement`, `Expression`, and so forth, and now we are going to define them for real.

## Interning

We'll start with `FunctionId` and `VariableId`.
These were two different names for interned strings.
Interning is a builtin feature to salsa where you take a complex data structure (in this case, a string) and replace it with a single integer.
The integer you get back is arbitrary, but whenever you intern the same thing twice (within one revision -- more on this caveat later), you get back the same integer.

Interned structs in Salsa are defined with the `#[salsa::interned]` attribute macro:

```rust
{{#include ../../../calc-example/calc/src/ir.rs:interned_ids}}
```

Note though that the structs that result from this declaration are _very different_ from what you wrote. When you intern a struct, the actual _data_ of the struct is stored in the salsa database, and the struct you get back is just a lightweight struct that wraps a `salsa::Id` struct. Since this struct just wraps a simple integer, it is `Copy`, `Eq`, `Hash`, and `Ord`:

```rust
#[derive(Eq, PartialEq, Ord, PartialOrd, Copy, Clone, Hash)]
pub struct VariableId(salsa::Id);

#[derive(Eq, PartialEq, Ord, PartialOrd, Copy, Clone, Hash)]
pub struct FunctionId(salsa::Id);
```

These interned structs also have a few methods:

- The `new` method creates an interned struct given a database `db` and a value for each field (e.g., `let v = VariableId::new(db, "foo".to_string())`).
- For each field of the interned struct, there is an accessor method with the same name (e.g., `v.name(db)`).
  - If the field is marked with `#[id(ref)]`, as it is here, than this accessor returns a reference! In this case, it returns an `&String` tied to the database `db`. This is useful when the values of the fields are not `Copy`.
  - The `id` here refers to the fact that the value of this field is part of the _identity_, i.e., it affects the `salsa::Id` integer. For interned structs, all fields are `id` fields, but later on we'll see entity structs, which also have `value` fields.

### The data struct

In addition to the main `VariableId` and `FunctionId` structs, the `salsa::interned` macro also creates a "data struct".
This is normally named the same as the original struct, but with `Data` appended to the end (i.e., `VariableIdData` and `FunctionIdData`).
You can override the name by using the `data` option (`#[salsa::interned(data = MyName)]`).
The data struct also inherits all the `derive` and other attributes from the original source.
In the case of our examples, the generated data struct would be something like:

```rust
// Generated by `salsa::interned`

#[derive(Eq, PartialEq, Clone, Hash)]
pub struct VariableIdData {
    pub text: String,
}

#[derive(Eq, PartialEq, Clone, Hash)]
pub struct FunctionIdData {
    pub text: String,
}
```

## Expressions and statements

We'll also intern expressions and statements. This is convenient primarily because it allows us to have recursive structures very easily. Since we don't really need the "cheap equality comparison" aspect of interning, this isn't the most efficient choice, and many compilers would opt to represent expressions/statements in some other way.

```rust
{{#include ../../../calc-example/calc/src/ir.rs:statements_and_expressions}}
```

## Function entities

The final piece of our IR is the representation of _functions_. Here, we use an _entity struct_:

```rust
{{#include ../../../calc-example/calc/src/ir.rs:functions}}
```

An **entity** is very similar to an interned struct, except that it has own identity. That is, each time you invoke `Function::new`, you will get back a new `Function, even if all the values of the fields are equal.

### Interning vs entities

Unless you want a cheap way to compare for equality across functions, you should prefer entities to interning. They correspond most closely to creating a "new" struct.

### id fields

To get better reuse across revisions, particularly when things are reordered, you can mark some entity fields with `#[id]`.
Normally, you would do this on fields that represent the "name" of an entity.
This indicates that, across two revisions R1 and R2, if two functions are created with the same name, they refer to the same entity, so we can compare their other fields for equality to determine what needs to be re-executed.
Adding `#[id]` attributes is an optimization and never affects correctness.
For more details, see the [algorithm](../reference/algorithm.md) page of the reference.
