# Defining the IR

Before we can define the [parser](./parser.md), we need to define the intermediate representation (IR) that we will use for `calc` programs.
In the [basic structure](./structure.md), we defined some "pseudo-Rust" structures like `Statement`, `Expression`, and so forth, and now we are going to define them for real.

## Input

The first thing we will define is our **input**. 
Every salsa program has some basic inputs that drive the rest of the computation.
The rest of the program must be some deterministic function of those base inputs,
such that when those inputs change, we can try to efficiently recompute the new result of that function.

Inputs are defined as Rust structs with a `#[salsa::input]` annotation:

```rust
{{#include ../../../calc-example/calc/src/ir.rs:input}}
```

In our compiler, we have just one simple input, the `ProgramSource`, which has a `text` field (the string).
(By the way, the `#[salsa::input]` annotation must be connected to a jar, but it defaults to `crate::Jar`.
If you wanted to create the jar somewhere else, you would write `#[salsa::input(jar = path::to::Jar)]`.
Wherever the jar is defined, you also have to list the input as one of its fields.)

### The data lives in the database

Although they are declared like other Rust structs, salsa structs are implemented quite differently.
The values of their fields are stored in the salsa database, and the struct itself just contains a numeric identifier.
This means that the struct instances are copy (no matter what fields they contain).
Creating instances of the struct and accessing fields is done by invoking methods like `new` as well as getters and setters.

More concretely, the `#[salsa::input]` annotation will generate a struct for `ProgramSource` like this:

```rust
#[define(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ProgramSource(salsa::Id);
```

It will also generate a method `new` that lets you create a `ProgramSource` in the database.
For an input, a `&mut db` reference is required, along with the values for each field:

```rust
let source = ProgramSource::new(&mut db, "print 11 + 11".to_string());
```

You can read the value of the field with `source.text(db)`, 
and you can set the value of the field with `source.set_text(&mut db, "print 11 * 2".to_string())`.

## Interning

Interning is a builtin feature to salsa where you take a struct and replace it with a single integer.
The integer you get back is arbitrary, but whenever you intern the same struct twice, you get back the same integer.
In our compiler, we'll use interning to define `FunctionId` and `VariableId`, which are effectively interned strings.

Interned structs in Salsa are defined with the `#[salsa::interned]` attribute macro:

```rust
{{#include ../../../calc-example/calc/src/ir.rs:interned_ids}}
```

As with `#[salsa::input]`, the data for an interned struct is stored in the database, and the struct itself is just an integer. 
The interned structs have a few methods.

These interned structs also have a few methods:

- The `new` method creates an interned struct given a database `db` and a value for each field (e.g., `let v = VariableId::new(db, "foo".to_string())`).
- For each field of the interned struct, there is an accessor method with the same name (e.g., `v.name(db)`).
  - If the field is marked with `#[id(ref)]`, as it is here, than this accessor returns a reference! In this case, it returns an `&String` tied to the database `db`. This is useful when the values of the fields are not `Copy`.
  - The `id` here refers to the fact that the value of this field is part of the _identity_, i.e., it affects the `salsa::Id` integer. For interned structs, all fields are `id` fields, but later on we'll see entity structs, which also have `value` fields.

### The data struct

In addition to the main `VariableId` and `FunctionId` structs, the `salsa::interned` macro also creates a "data struct".
This is normally named the same as the original struct, but with `Data` appended to the end (i.e., `VariableIdData` and `FunctionIdData`).
You can override the name by using the `data` option (`#[salsa::interned(data = MyName)]`).
The data struct also inherits all the `derive` and other attributes from the original source.
In the case of our examples, the generated data struct would be something like:

```rust
// Generated by `salsa::interned`

#[derive(Eq, PartialEq, Clone, Hash)]
pub struct VariableIdData {
    pub text: String,
}

#[derive(Eq, PartialEq, Clone, Hash)]
pub struct FunctionIdData {
    pub text: String,
}
```

## Expressions and statements

We'll also intern expressions and statements. This is convenient primarily because it allows us to have recursive structures very easily. Since we don't really need the "cheap equality comparison" aspect of interning, this isn't the most efficient choice, and many compilers would opt to represent expressions/statements in some other way.

```rust
{{#include ../../../calc-example/calc/src/ir.rs:statements_and_expressions}}
```

## Function entities

The final piece of our IR is the representation of _functions_. Here, we use an _entity struct_:

```rust
{{#include ../../../calc-example/calc/src/ir.rs:functions}}
```

An **entity** is very similar to an interned struct, except that it has own identity. That is, each time you invoke `Function::new`, you will get back a new `Function, even if all the values of the fields are equal.

### Interning vs entities

Unless you want a cheap way to compare for equality across functions, you should prefer entities to interning. They correspond most closely to creating a "new" struct.

### id fields

To get better reuse across revisions, particularly when things are reordered, you can mark some entity fields with `#[id]`.
Normally, you would do this on fields that represent the "name" of an entity.
This indicates that, across two revisions R1 and R2, if two functions are created with the same name, they refer to the same entity, so we can compare their other fields for equality to determine what needs to be re-executed.
Adding `#[id]` attributes is an optimization and never affects correctness.
For more details, see the [algorithm](../reference/algorithm.md) page of the reference.
