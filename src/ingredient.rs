use std::{
    any::{Any, TypeId},
    fmt,
};

use crate::{
    cycle::CycleRecoveryStrategy, key::DependencyIndex, runtime::local_state::QueryOrigin,
    storage::IngredientIndex, DatabaseKeyIndex, Id,
};

use super::Revision;

pub(crate) mod adaptor;

/// A "jar" is a group of ingredients that are added atomically.
/// Each type implementing jar can be added to the database at most once.
pub trait Jar: Any {
    /// The database view trait required by this jar (and all its ingredients).
    type DbView: ?Sized;

    /// Create the ingredients given the index of the first one.
    /// All subsequent ingredients will be assigned contiguous indices.
    fn create_ingredients(
        &self,
        first_index: IngredientIndex,
    ) -> Vec<Box<dyn Ingredient<DbView = Self::DbView>>>;
}

/// "Ingredients" are the bits of data that are stored within the database to make salsa work.
/// Each jar will define some number of ingredients that it requires.
/// Each use salsa macro (e.g., `#[salsa::tracked]`, `#[salsa::interned]`) adds one or more
/// ingredients to the jar struct that together are used to create the salsa concept.
/// For example, a tracked struct defines a [`crate::interned::InternedIngredient`] to store
/// its identity plus [`crate::function::FunctionIngredient`] values to store its fields.
/// The exact ingredients are determined by
/// [`IngredientsFor`](`crate::storage::IngredientsFor`) implementations generated by the
/// macro.
pub trait Ingredient: RawIngredient {
    /// The database view trait required by this ingredient.
    type DbView: ?Sized;

    /// Workaround lack of builtin trait upcasting; just return `self` in your impl.
    fn upcast_to_raw(&self) -> &dyn RawIngredient;

    /// Workaround lack of builtin trait upcasting; just return `self` in your impl.
    fn upcast_to_raw_mut(&mut self) -> &mut dyn RawIngredient;

    /// Returns the [`IngredientIndex`] of this ingredient.
    fn ingredient_index(&self) -> IngredientIndex;

    /// If this ingredient is a participant in a cycle, what is its cycle recovery strategy?
    /// (Really only relevant to [`crate::function::FunctionIngredient`],
    /// since only function ingredients push themselves onto the active query stack.)
    fn cycle_recovery_strategy(&self) -> CycleRecoveryStrategy;

    /// Has the value for `input` in this ingredient changed after `revision`?
    fn maybe_changed_after<'db>(
        &'db self,
        db: &'db Self::DbView,
        input: DependencyIndex,
        revision: Revision,
    ) -> bool;

    /// What were the inputs (if any) that were used to create the value at `key_index`.
    fn origin(&self, key_index: Id) -> Option<QueryOrigin>;

    /// Invoked when the value `output_key` should be marked as valid in the current revision.
    /// This occurs because the value for `executor`, which generated it, was marked as valid
    /// in the current revision.
    fn mark_validated_output<'db>(
        &'db self,
        db: &'db Self::DbView,
        executor: DatabaseKeyIndex,
        output_key: Option<Id>,
    );

    /// Invoked when the value `stale_output` was output by `executor` in a previous
    /// revision, but was NOT output in the current revision.
    ///
    /// This hook is used to clear out the stale value so others cannot read it.
    fn remove_stale_output(
        &self,
        db: &Self::DbView,
        executor: DatabaseKeyIndex,
        stale_output_key: Option<Id>,
    );

    /// Informs the ingredient `self` that the salsa struct with id `id` has been deleted.
    /// This gives `self` a chance to remove any memoized data dependent on `id`.
    /// To receive this callback, `self` must register itself as a dependent function using
    /// [`SalsaStructInDb::register_dependent_fn`](`crate::salsa_struct::SalsaStructInDb::register_dependent_fn`).
    fn salsa_struct_deleted(&self, db: &Self::DbView, id: Id);

    /// Invoked when a new revision is about to start.
    /// This moment is important because it means that we have an `&mut`-reference to the
    /// database, and hence any pre-existing `&`-references must have expired.
    /// Many ingredients, given an `&'db`-reference to the database,
    /// use unsafe code to return `&'db`-references to internal values.
    /// The backing memory for those values can only be freed once an `&mut`-reference to the
    /// database is created.
    ///
    /// **Important:** to actually receive resets, the ingredient must set
    /// [`IngredientRequiresReset::RESET_ON_NEW_REVISION`] to true.
    fn reset_for_new_revision(&mut self);

    fn fmt_index(&self, index: Option<crate::Id>, fmt: &mut fmt::Formatter<'_>) -> fmt::Result;
}

/// The "raw" version of an ingredient can be downcast to more specific types.
/// This trait is automatically implemented and basically just defines an alias
/// for [`Any`][].
pub trait RawIngredient: Any {}
impl<T: ?Sized + Ingredient> RawIngredient for T {}

impl dyn RawIngredient {
    pub fn assert_type<I: Any>(&self) -> &I {
        assert_eq!(
            self.type_id(),
            TypeId::of::<I>(),
            "expecetd a value of type `{}` but type check failed",
            std::any::type_name::<I>(),
        );

        let raw: *const dyn RawIngredient = self;
        let raw: *const I = raw as _; // disregards the metadata along the way
        unsafe { &*raw } // valid b/c of type check above
    }
}

/// A helper function to show human readable fmt.
pub(crate) fn fmt_index(
    debug_name: &str,
    id: Option<Id>,
    fmt: &mut fmt::Formatter<'_>,
) -> fmt::Result {
    if let Some(i) = id {
        write!(fmt, "{}({})", debug_name, u32::from(i))
    } else {
        write!(fmt, "{}()", debug_name)
    }
}

/// Defines a const indicating if an ingredient needs to be reset each round.
/// This const probably *should* be a member of `Ingredient` trait but then `Ingredient` would
/// not be dyn-safe.
pub trait IngredientRequiresReset {
    /// If this is true, then `reset_for_new_revision` will be called every new revision.
    const RESET_ON_NEW_REVISION: bool;
}
